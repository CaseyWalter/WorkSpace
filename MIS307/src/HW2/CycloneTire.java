package HW2;
import java.util.Random;

/**
 * Code for HW2
 * Casey Walter
 */
public class CycloneTire {

	Random rnd;
	double promotion_claim = 30000;
	double tire_life_mean = 35000;
	double tire_life_stddev = 4500;
	double promotion_cost_per_mile = 0.01;
	double[] tireLives;
	
	public double avg_promotion_cost;
	public double prob_refund_GE50;
	
	// Complete this method to run simulation experiment
	public void runSimulation(int numSimulation) {
		rnd = new Random();
		tireLives = new double[numSimulation]; // stores the tire lives generated by simulation
		
		// Step1: write a for loop to generate tire life values and store them in the results array
		
		
		
		for(int tireValues = 0; tireValues < numSimulation; tireValues++) {
			tireLives[tireValues] = nextNormal(tire_life_mean , tire_life_stddev); 
		}
		
		
		

		// Step2: write a for loop to update sum_cost and num_GE50
		// Hint: cost is positive only if tire life is smaller than promotion_claim (30000 miles). Hence, if statement should be used. 
		//       If tire life is smaller than promotion_claim, first calculate shortage, then calculate cost.
		double sum_cost = 0; // sum of costs for all tires
		int num_GE50 = 0; // number of cases (tires) with refund great than or equal to $50
    	
		
		for(int i = 0; i < numSimulation; i++) {
			if (tireLives[i] < promotion_claim) {
				sum_cost += (promotion_claim - tireLives[i]) * promotion_cost_per_mile;
			} 
			
		} 
		for(int x = 0; x < numSimulation; x++) {
			  if(tireLives[x] <= 25000) {
					num_GE50++;
				}
		 }
		
    	
    	// Step3: Use sum_cost and num_GE50 to calculate avg_promotion_cost and prob_refund_GE50
    	
		avg_promotion_cost = sum_cost / numSimulation; 
		prob_refund_GE50 = (double)num_GE50 / numSimulation;
    	
    	
    	
    	
	}
	
    
	// returns a Normal random number given mean and stddev
	// THIS METHOD IS COMPLETE. DO NOT CHANGE.
    private double nextNormal(double mean, double stddev)
    {
        double randStdNormal = nextStandardNormal();
        double randNormal = mean + stddev * randStdNormal;
        return randNormal;
    }
    
    // returns a standard Normal random number
    // THIS METHOD IS COMPLETE. DO NOT CHANGE.
    private double nextStandardNormal()
    {
        double u1 = rnd.nextDouble();
        double u2 = rnd.nextDouble();
        double randStdNormal = Math.sqrt(-2.0 * Math.log(u1)) * Math.sin(2.0 * Math.PI * u2);
        return randStdNormal;
    }
}
